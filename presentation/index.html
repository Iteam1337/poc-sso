<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Simplifying Authentication in Microservice Architectures</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reset.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/night.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/monokai.css">
  <style>
    .reveal pre {
      margin: 0;
      width: 100%;
      box-shadow: none;
    }
    .reveal pre code {
      padding: 20px;
      max-height: 400px;
      font-size: 0.8em;
    }
    .reveal section img {
      border: none;
      box-shadow: none;
      background: none;
    }
    .reveal h1, .reveal h2, .reveal h3, .reveal h4 {
      text-transform: none;
    }
    .reveal .highlight {
      color: #42affa;
    }
    .reveal .warning {
      color: #ff5252;
    }
    .reveal .success {
      color: #4caf50;
    }
    .two-columns {
      display: flex;
      justify-content: space-between;
    }
    .two-columns .column {
      width: 48%;
    }
    .reveal .small-code pre code {
      font-size: 0.6em;
      line-height: 1.2;
    }
    .reveal .smaller {
      font-size: 0.8em;
    }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides">
      <!-- TITLE SLIDE -->
      <section data-background-gradient="linear-gradient(to bottom, #1a237e, #283593)">
        <h1>Simplifying Authentication in Microservice Architectures</h1>
        <h3>Using Keycloak for Centralized Identity Management</h3>
        <p>Weekly Code Lunch - <span id="current-date"></span></p>
        <script>
          document.getElementById('current-date').textContent = new Date().toLocaleDateString('sv-SE');
        </script>
      </section>

      <!-- WHY SECTION -->
      <section>
        <section data-background-color="#2a2a2a">
          <h2>Why This Matters</h2>
          <p>Authentication is a <span class="highlight">critical component</span> of any application</p>
          <ul>
            <li>Security breaches often start with authentication vulnerabilities</li>
            <li>Microservices multiply the authentication challenge</li>
            <li>Inconsistent implementation leads to security gaps</li>
            <li>Developers spend too much time reimplementing auth</li>
          </ul>
          <aside class="notes">
            Authentication is often treated as an afterthought, but it's one of the most critical components of any application.
            Many security breaches start with authentication vulnerabilities.
            In microservice architectures, this challenge is multiplied across services.
          </aside>
        </section>
        <section>
          <h3>The Cost of Poor Authentication</h3>
          <ul>
            <li>Security vulnerabilities</li>
            <li>Developer time wasted on reinventing the wheel</li>
            <li>Inconsistent user experience</li>
            <li>Difficulty scaling the system</li>
            <li>Maintenance burden</li>
          </ul>
        </section>
      </section>

      <!-- PROBLEM SECTION -->
      <section>
        <section data-background-color="#2a2a2a">
          <h2>The Problem</h2>
          <p>Microservice architectures introduce <span class="highlight">complex authentication challenges</span></p>
          <div class="mermaid">
            graph TD
                A[Frontend App] --> B[BFF/API Gateway]
                B --> C[Microservice 1]
                B --> D[Microservice 2]
                B --> E[Microservice 3]
          </div>
          <aside class="notes">
            In a microservice architecture, each service potentially needs to verify user identity.
            This creates multiple authentication points, increasing complexity and potential security issues.
          </aside>
        </section>
        <section>
          <h3>Key Challenges</h3>
          <ol>
            <li><strong>Multiple Authentication Points</strong>: Each microservice needs to verify identity</li>
            <li><strong>Secret Management</strong>: Secure storage of client secrets and keys</li>
            <li><strong>Token Verification</strong>: Each service needs to validate tokens independently</li>
            <li><strong>Consistent Implementation</strong>: Maintaining consistent auth logic</li>
            <li><strong>Frontend Complexity</strong>: Secure token management in the browser</li>
          </ol>
        </section>
        <section>
          <h3>Common Anti-Patterns</h3>
          <ul>
            <li class="warning">Storing tokens in localStorage (XSS vulnerability)</li>
            <li class="warning">Custom auth implementation in each microservice</li>
            <li class="warning">Duplicating auth logic across services</li>
            <li class="warning">Passing tokens through multiple services</li>
            <li class="warning">Exposing client secrets to frontend code</li>
          </ul>
        </section>
      </section>

      <!-- VISION SECTION -->
      <section>
        <section data-background-color="#2a2a2a">
          <h2>The Vision</h2>
          <p>A <span class="highlight">centralized, secure, and standardized</span> authentication system</p>
          <ul>
            <li>Single source of truth for identity</li>
            <li>Secure token handling</li>
            <li>Consistent implementation across services</li>
            <li>Reduced frontend complexity</li>
            <li>Follows security best practices</li>
          </ul>
          <aside class="notes">
            Our vision is to create a centralized authentication system that provides a single source of truth for identity,
            handles tokens securely, and provides a consistent implementation across all services.
          </aside>
        </section>
        <section>
          <h3>What Success Looks Like</h3>
          <ul>
            <li>Developers focus on business logic, not auth</li>
            <li>Consistent security across all services</li>
            <li>Simplified onboarding for new services</li>
            <li>Reduced attack surface</li>
            <li>Compliance with security best practices</li>
          </ul>
        </section>
      </section>

      <!-- SOLUTION SECTION -->
      <section>
        <section data-background-color="#2a2a2a">
          <h2>The Solution</h2>
          <p>Centralized Identity with <span class="highlight">Keycloak</span></p>
          <div class="mermaid">
            graph TD
                A[Frontend App] -->|1. Auth Request| K[Keycloak]
                K -->|2. Auth Code| A
                A -->|3. Code| B[Backend API]
                B -->|4. Token Exchange| K
                K -->|5. Tokens + JWT| B
                B -->|6. Set HTTP-only Cookie| A
                A -->|7. Cookie-based Requests| B
                B -->|8. Verify Token| C[Microservices]
          </div>
          <aside class="notes">
            Keycloak provides a comprehensive identity and access management solution.
            It centralizes authentication and provides secure token handling.
            The frontend delegates token handling to the backend, reducing complexity and improving security.
          </aside>
        </section>
        <section>
          <h3>Key Benefits</h3>
          <ul>
            <li class="success">Centralized Authentication: Single source of truth</li>
            <li class="success">Secure Token Handling: HTTP-only cookies</li>
            <li class="success">JWKS Verification: Services verify tokens using public keys</li>
            <li class="success">Standardized Implementation: Consistent auth across services</li>
            <li class="success">Reduced Frontend Complexity: Frontend delegates token handling</li>
          </ul>
        </section>
        <section>
          <h3>OWASP Security Considerations</h3>
          <div class="two-columns">
            <div class="column">
              <h4 class="warning">Why Not localStorage?</h4>
              <ul>
                <li>Vulnerable to XSS Attacks</li>
                <li>No Expiration Mechanism</li>
                <li>Available to All Scripts</li>
              </ul>
            </div>
            <div class="column">
              <h4 class="success">Our Approach</h4>
              <ul>
                <li>HTTP-Only Cookies</li>
                <li>Secure Flag</li>
                <li>SameSite Attribute</li>
                <li>Short Expiration</li>
                <li>Backend Token Exchange</li>
              </ul>
            </div>
          </div>
        </section>
      </section>

      <!-- IMPLEMENTATION DETAILS -->
      <section>
        <section data-background-color="#2a2a2a">
          <h2>Implementation Details</h2>
          <p>How we built it with <span class="highlight">React</span> and <span class="highlight">Node.js</span></p>
          <ul>
            <li>Frontend Authentication Flow</li>
            <li>Secure Backend Token Exchange</li>
            <li>Token Verification with JWKS</li>
            <li>Protected API Endpoints</li>
          </ul>
          <aside class="notes">
            Let's look at how we implemented this solution using React for the frontend and Node.js for the backend.
            We'll cover the frontend authentication flow, secure backend token exchange, token verification with JWKS, and protected API endpoints.
          </aside>
        </section>
        <section>
          <h3>Frontend Authentication Flow</h3>
          <div class="small-code">
            <pre><code class="javascript">// authService.js - Initiates login without handling tokens directly
initiateLogin() {
  const redirectUri = `${window.location.origin}/callback`;
  const encodedRedirectUri = encodeURIComponent(redirectUri);
  
  const authUrl = `${KEYCLOAK_URL}/protocol/openid-connect/auth?client_id=${CLIENT_ID}&redirect_uri=${encodedRedirectUri}&response_type=code&scope=openid email profile&state=${Date.now()}`;

  window.location.href = authUrl;
}

// authService.js - Exchanges code for token via backend
async exchangeCodeForToken(code) {
  const redirectUri = `${window.location.origin}/callback`;
  
  const response = await axios.post(
    '/api/token',
    {
      code: code,
      redirect_uri: redirectUri,
    },
    {
      withCredentials: true, // Important for cookies to be sent/received
    }
  );
  
  return response.data;
}</code></pre>
          </div>
        </section>
        <section>
          <h3>Secure Backend Token Exchange</h3>
          <div class="small-code">
            <pre><code class="javascript">// Token exchange endpoint
app.post('/api/token', async (req, res) => {
  try {
    const { code, redirect_uri } = req.body;
    
    // Exchange the authorization code for tokens
    const tokenData = await tokenService.exchangeCodeForTokens(
      code,
      redirect_uri,
    );
    
    // Set cookies with the tokens
    tokenService.setCookies(res, tokenData);
    
    // Extract user info from token with verification
    const user = await tokenService.extractUserFromToken(
      tokenData.access_token,
      jwksService,
    );
    
    res.json({
      message: 'Authentication successful',
      user,
      expiresIn: tokenData.expires_in,
    });
  } catch (error) {
    console.error('Token exchange error:', error.response?.data || error.message);
    res.status(401).json({
      error: 'Token exchange failed',
      details: error.response?.data || error.message,
    });
  }
});</code></pre>
          </div>
        </section>
        <section>
          <h3>Secure Token Storage</h3>
          <div class="small-code">
            <pre><code class="javascript">// tokenService.js - Setting secure HTTP-only cookies
setCookies(res, { access_token, refresh_token, expires_in }) {
  // Set the access token as an HTTP-only cookie
  res.cookie('auth_token', access_token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: expires_in * 1000,
  });
  
  // Store refresh token in a separate cookie
  if (refresh_token) {
    res.cookie('refresh_token', refresh_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    });
  }
}</code></pre>
          </div>
        </section>
        <section>
          <h3>Token Verification with JWKS</h3>
          <div class="small-code">
            <pre><code class="javascript">// jwksService.js - Verifying tokens with JWKS
async verifyToken(token) {
  try {
    const jwks = await this.getJwks();
    
    // Verify the token
    const { payload } = await jose.jwtVerify(token, jwks, {
      issuer: this.keycloakUrl,
      audience: 'account'  // This might need to be adjusted based on your Keycloak configuration
    });
    
    return payload;
  } catch (error) {
    console.error('Token verification failed:', error.message);
    throw error;
  }
}</code></pre>
          </div>
        </section>
        <section>
          <h3>Protected API Endpoints</h3>
          <div class="small-code">
            <pre><code class="javascript">// auth.js middleware - Extracting and verifying JWT from cookies
const extractJwtToken = (jwksService) => async (req, res, next) => {
  try {
    // First check for token in cookie
    const token = req.cookies.auth_token;
    
    // Fallback to Authorization header if no cookie
    const authHeader = req.headers.authorization;
    const headerToken = authHeader && authHeader.startsWith('Bearer ') 
      ? authHeader.split(' ')[1] 
      : null;
    
    // Use token from cookie or header
    const accessToken = token || headerToken;
    
    if (!accessToken) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    try {
      // Verify the token using JWKS
      const decodedToken = await jwksService.verifyToken(accessToken);
      
      req.user = {
        id: decodedToken.sub,
        email: decodedToken.email,
        name: decodedToken.name,
        preferred_username: decodedToken.preferred_username,
        source: 'keycloak'
      };
      
      next();
    } catch (tokenError) {
      console.error('Token verification error:', tokenError.message);
      return res.status(401).json({ error: 'Invalid token' });
    }
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(401).json({ error: 'Authentication failed' });
  }
};</code></pre>
          </div>
        </section>
      </section>

      <!-- SCALING SECTION -->
      <section>
        <section data-background-color="#2a2a2a">
          <h2>Scaling to Multiple Microservices</h2>
          <div class="mermaid">
            graph TD
                A[Frontend] -->|Auth Code| B[API Gateway]
                B -->|Token Exchange| K[Keycloak]
                B -->|Verified Requests| C[Service 1]
                B -->|Verified Requests| D[Service 2]
                B -->|Verified Requests| E[Service 3]
                C -->|JWKS Verification| K
                D -->|JWKS Verification| K
                E -->|JWKS Verification| K
          </div>
          <p class="smaller">Each microservice can independently verify tokens using Keycloak's JWKS endpoint</p>
          <aside class="notes">
            This pattern scales well to multiple microservices. Each service can independently verify tokens using Keycloak's JWKS endpoint, without needing to share secrets.
          </aside>
        </section>
      </section>

      <!-- NEXT STEPS -->
      <section>
        <section data-background-color="#2a2a2a">
          <h2>Next Steps</h2>
          <ul>
            <li>Implement refresh token rotation</li>
            <li>Add role-based access control</li>
            <li>Set up multi-factor authentication</li>
            <li>Create service templates for quick onboarding</li>
            <li>Implement monitoring and alerting</li>
          </ul>
          <aside class="notes">
            Our next steps include implementing refresh token rotation, adding role-based access control, setting up multi-factor authentication, creating service templates for quick onboarding, and implementing monitoring and alerting.
          </aside>
        </section>
      </section>

      <!-- CONCLUSION -->
      <section data-background-gradient="linear-gradient(to bottom, #283593, #1a237e)">
        <h2>Conclusion</h2>
        <p>By centralizing authentication with Keycloak, we've:</p>
        <ul>
          <li>Simplified authentication in our microservice architecture</li>
          <li>Improved security by following best practices</li>
          <li>Reduced complexity for developers</li>
          <li>Created a scalable solution for future growth</li>
        </ul>
        <p><strong>Questions?</strong></p>
      </section>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/notes/notes.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/markdown/markdown.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/plugin/highlight/highlight.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
  <script>
    // Initialize Reveal.js
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      transition: 'slide',
      plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ],
      dependencies: [
        { src: 'https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js', async: true }
      ]
    });

    // Initialize Mermaid
    mermaid.initialize({
      startOnLoad: false,
      theme: 'dark',
      securityLevel: 'loose'
    });

    // Render Mermaid diagrams when the slide is shown
    Reveal.on('slidechanged', event => {
      const currentSlide = event.currentSlide;
      const diagrams = currentSlide.querySelectorAll('.mermaid');
      if (diagrams.length > 0) {
        mermaid.init(undefined, diagrams);
      }
    });

    // Render Mermaid diagrams on initial load
    Reveal.on('ready', event => {
      const currentSlide = event.currentSlide;
      const diagrams = currentSlide.querySelectorAll('.mermaid');
      if (diagrams.length > 0) {
        mermaid.init(undefined, diagrams);
      }
    });
  </script>
</body>
</html>
